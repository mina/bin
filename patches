#!/bin/sh
#
# Workflow:
# git co -b my-branch --track net-next/main
# vim ...
# git a .
# git cm -m "my patch"
#
# # Creates patches under my-branch/
# patches create -v 1
#
# # Runs checkpatch
# patches checkpatch
#
# # Runs patch-by-patch W=1 C=1 in a git rebase --exec
# patches build_patch_by_patch
#	# if you run into errors
#	vim ...				# fix the errors
#	git cm --amend			# commit the fixes
#	build_patch_with_checks.sh	# check if the errors still happen
#	git rebase --continue		# Carry on with the patch-by-patch build
#
# # Build patch-by-patch allmodconfig in a git rebase --exec
# patches build_allmodconfig_patch_by_patch
#
# # clang-format each patch in a git rebase --exec
# patches clang_format
#
# # Send the patches upstream
# patches send -v 1

set -euo pipefail
# Turn on for debugging
set -x

TEST="${TEST:-0}"

head=$(git rev-parse --abbrev-ref --symbolic-full-name HEAD)
parent=$(git rev-parse --abbrev-ref --symbolic-full-name @{u})
RANGE="${RANGE:-"$parent..HEAD"}"
git_send_to="netdev@vger.kernel.org"

echoerr() { cat <<< "$@" 1>&2; }

function create() {
	rm -rf $head

	cover_letter=""
	set +e
	git config branch.$head.description > .description.txt && \
		cover_letter="1"
	set -e

	count=$(($(git rev-list --count "$RANGE")))

	if [[ $count < 1 ]]; then
		echo "Not enough commits in range: $count"
		exit 1
	fi

	if [[ $count > 1 ]] && [ ! -z "$cover_letter" ]; then
		cover_letter="--cover-letter --cover-from-description=auto --description-file=.description.txt"
	else
		cover_letter=""
	fi

	to=$(git diff "$RANGE" | ./scripts/get_maintainer.pl --nogit-fallback \
		--norolestats -nom -nor --nomoderated --nomultiline)
	cc=$(git diff "$RANGE" | ./scripts/get_maintainer.pl --nogit-fallback \
		--norolestats -nol --nomoderated --nomultiline)

	if [[ $TEST != 0 ]]; then
		to=""
		cc=""
	fi

	files=$(git format-patch \
		-o $head \
		"$RANGE" \
		$cover_letter \
		--to="$to" \
		--cc="$cc" \
		--subject-prefix='PATCH net-next' \
		"$@")

	# Delete change-id
	for file in $files; do
		sed '/Change-Id:/d' $file -i
	done

	echo $files
}

send() {
	files=$(create $@)

	if [[ $TEST != 0 ]]; then
		git_send_to="$USER@google.com"
	fi

	yes | git send-email $files --to="$git_send_to" --cc-cover --8bit-encoding=UTF-8 $CONFIRM

	git tag "$head-send-patches-$(date +%F-%s)"
}

checkpatch() {
	files=$(create $@)

	# checkpatch
	for file in $files; do
		set +e
		./scripts/checkpatch.pl --patch $file --codespell
		set -e
	done

	# kernel-doc
	files=$(git diff "$RANGE" --name-only)
	echo kernel-doc...
	for file in $files; do
		./scripts/kernel-doc -none $file
	done
	echo done kernel-doc
}

build_allmodconfig_patch_by_patch() {
	make allmodconfig
	git rebase --exec \
		'git show | grep -q "not-for-review" || make -s -j80' \
		$parent

	echo "Test build patches succeeded"

	git tag "$head-build-allmodconfig-patch-by-patch-$(date +%F-%s)"
}

build_patch_by_patch() {
	touch .first_in_series

	git rebase --exec \
		'git show | grep -q "not-for-review" || PATCHES_CONFIG=allnoconfig ~/bin/build_patch_with_checks.sh' \
		$parent

	echo "Test build patches succeeded"
	git tag "$head-patch-by-patch-$(date +%F-%s)"
}

clang_format() {
	git rebase --exec \
		'git show | grep -q "not-for-review" || git diff -U0 --no-color HEAD~ | /usr/lib/clang-format/clang-format-diff.py -i -p1' $1
}

command="$1"
shift

if [ "$command" == "create" ]; then
	create $@
elif [ "$command" == "send" ]; then
	send $@
elif [ "$command" == "send_no_confirm" ]; then
	CONFIRM="--confirm=never" send $@
elif [ "$command" == "checkpatch" ]; then
	checkpatch $@
elif [ "$command" == "build_patch_by_patch" ]; then
	build_patch_by_patch $@
elif [ "$command" == "build_allmodconfig_patch_by_patch" ]; then
	build_allmodconfig_patch_by_patch $@
elif [ "$command" == "clang_format" ]; then
	clang_format $@
fi
